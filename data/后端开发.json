[
    {
        "问题": "你个人的规划是什么，后面的读研什么的怎么考虑？",
        "答案": "我的个人规划是先完成本科学业，打好专业基础，尤其是计算机相关的数据结构、算法和编程能力。在本科阶段我会积极参与项目实践、实习机会，提升自己的工程能力和行业认知。关于读研的考虑，我倾向于根据未来的发展情况来决定。如果发现对科研有浓厚兴趣，或者希望在某个细分领域深入研究，我会选择攻读研究生；如果更倾向于快速进入职场积累经验，我也会积极准备校招，争取进入优秀的科技企业工作。"
    },
    {
        "问题": "岛屿的最大面积求解。",
        "答案": "岛屿的最大面积问题通常出现在二维网格中，其中1代表陆地（land），0代表水（water）。岛屿是由相邻的1组成的，且被0包围的最大连接区域。该问题的目标是找出最大岛屿的面积。可以通过深度优先搜索（DFS）或广度优先搜索（BFS）来解决。"
    },
    {
        "问题": "mysql 里面的事务是怎么实现的？",
        "答案": "MySQL 中的事务是通过日志系统（Redo Log 和 Undo Log）和事务隔离级别机制共同实现的。事务的实现主要依赖 InnoDB 存储引擎，它通过原子性、一致性、隔离性和持久性（ACID）来确保数据的正确性和可靠性。"
    },
    {
        "问题": "怎么保证 ACID 4 个特性？",
        "答案": "ACID 是数据库事务的四个基本特性，分别指原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。要保证这四个特性，需要通过日志、锁机制、并发控制等技术来实现。"
    },
    {
        "问题": "Http 请求里面有哪一些字段？",
        "答案": "HTTP 请求由客户端发送给服务器，主要包括以下几个部分：请求行（Request Line）、请求头（Headers）、请求体（Body，可选）。其中，请求行包括方法（Method）、请求的资源路径（Path）和 HTTP 版本（HTTP Version）。请求头中包含多个字段，用于传递客户端的元信息，如用户代理、内容类型、认证信息等。"
    },
    {
        "问题": "状态码 500 和 502 的区别？",
        "答案": "状态码 500 表示服务器内部错误（Internal Server Error），通常由服务器程序异常导致；502 表示网关或代理服务器从上游服务器收到无效响应（Bad Gateway）。二者都属于 HTTP 5xx 错误，但发生错误的层级不同。"
    },
    {
        "问题": "客户端和服务器的 TCP 长连接，如果客户端重启了，还可以用之前的 TCP 长连接吗？",
        "答案": "不可以。当客户端重启后，原有的 TCP 长连接会断开，因为 TCP 连接是基于客户端和服务器端的 IP 地址和端口号建立的。一旦客户端重启，其 IP 或端口号可能会变化，同时操作系统也会关闭所有之前的连接状态，因此服务器端会感知到连接中断，客户端必须重新发起连接请求，建立新的 TCP 连接。"
    },
    {
        "问题": "mysql查询语句一个流程？",
        "答案": "MySQL 查询语句的执行流程主要包括以下几个步骤：连接建立、查询缓存（可选）、解析 SQL 语句、生成执行计划、执行引擎调用存储引擎进行数据读取、返回结果。其中涉及的关键技术包括语法解析、查询优化、索引使用、事务隔离级别等。"
    },
    {
        "问题": "优化器怎么优化的？",
        "答案": "优化器是深度学习训练过程中用于调整模型参数（权重）的算法，其目标是最小化损失函数。常见的优化器包括SGD、Adam、RMSprop等。优化器通过计算损失函数对模型参数的梯度，并根据一定的更新规则来调整参数值。"
    },
    {
        "问题": "我们的sql其实也是一个字符串，那他到底是怎么执行的？",
        "答案": "SQL语句本质上是一个字符串，数据库系统通过解析、编译、优化和执行这四个阶段来处理这个字符串，最终完成对数据库的操作。整个过程涉及词法分析、语法分析、查询优化器、执行引擎等多个组件。"
    },
    {
        "问题": "redis有缓存，如果我数据库缓存足够大，是不是不需要redis了？",
        "答案": "即使数据库的缓存足够大，Redis 仍然在很多场景下是不可替代的。因为 Redis 不仅仅是缓存，它还提供了丰富的数据结构、高性能读写、持久化、分布式支持等功能，适用于多种高并发、低延迟的业务场景。"
    },
    {
        "问题": "说说缓存穿透和缓存雪崩怎么解决？",
        "答案": "缓存穿透是指查询一个既不在缓存也不在数据库中的数据，导致每次请求都打到数据库；缓存雪崩是指大量缓存同时失效，造成短时间内大量请求直接访问数据库，可能导致系统崩溃。解决方法包括： 缓存穿透的解决方案： 空值缓存（Null Caching）：对查询结果为空的情况也进行缓存，设置较短过期时间。 布隆过滤器（Bloom Filter）：用于快速判断某个 key 是否可能存在，减少无效查询。  缓存雪崩的解决方案： 设置不同的过期时间：避免所有缓存同时失效，可以在基础过期时间上加一个随机值。 高可用缓存架构：如 Redis 集群、多级缓存等。 降级熔断机制：当缓存不可用时，启用限流或降级策略，保护后端数据库。 解答思路： 首先明确两个问题的本质区别："
    },
    {
        "问题": "你自己该怎么实现布隆过滤器？",
        "答案": "初始化一个固定大小的位数组（bit array），所有位初始为0。 使用多个独立的哈希函数对输入元素进行哈希计算，得到多个位置索引。 插入元素时，将这些索引位置上的位设为1。 查询元素是否存在时，同样使用这些哈希函数计算索引，若所有对应位都为1，则认为该元素可能存在；只要有一个位为0，则肯定不存在。"
    },
    {
        "问题": "说说dns和tcp的过程。",
        "答案": "用户在浏览器输入 www.example.com。 浏览器发起DNS查询请求，获取该域名对应的IP地址。 DNS客户端发送查询请求给本地DNS服务器，可能递归或迭代地查找目标域名的IP地址。 获取到IP地址后，建立TCP三次握手连接。 然后通过HTTP/HTTPS等应用层协议进行数据交互。"
    },
    {
        "问题": "常见集合类有哪些？",
        "答案": "常见集合类是指在编程语言中用于存储和操作一组对象的数据结构。以Java为例，常见的集合类主要包括List、Set、Map三大接口及其具体实现类，如ArrayList、LinkedList、HashSet、TreeSet、HashMap、TreeMap等。"
    },
    {
        "问题": "说说索引的底层实现。",
        "答案": "数据库索引的底层实现通常基于B+树（B-Plus Tree）或哈希表（Hash Table），其中B+树是主流关系型数据库（如MySQL、Oracle）中默认使用的索引结构。它支持高效的范围查询和等值查询，并且适合磁盘存储系统。"
    },
    {
        "问题": "怎么实现线程池？",
        "答案": "线程池是一种多线程处理任务的机制，通过预先创建一定数量的线程并复用它们来提高系统性能。实现线程池的核心包括任务队列、线程集合、线程调度策略以及线程生命周期管理。"
    },
    {
        "问题": "说一下Java线程池的实现原理。",
        "答案": "Java线程池的实现原理是通过复用一组预先创建的线程来执行任务，避免频繁创建和销毁线程带来的开销。线程池的核心组件包括任务队列（BlockingQueue）、线程集合（Worker集合）、核心与最大线程数、拒绝策略等。其主要由ThreadPoolExecutor类实现。"
    },
    {
        "问题": "所有的情况都可以用索引覆盖吗？",
        "答案": "不是所有情况都可以使用索引覆盖。索引覆盖（Index Covering）是指一个查询可以仅通过索引完成，而不需要访问表数据。这要求查询所需的所有字段都包含在某个索引中。"
    },
    {
        "问题": "缓存过期策略了解吗？",
        "答案": "缓存过期策略是用于管理缓存中数据有效时间的机制，常见的有TTL（Time To Live）、TTI（Time To Idle）、LFU（Least Frequently Used）、LRU（Least Recently Used）等。这些策略决定了缓存项在多长时间内有效，以及在缓存满时如何淘汰旧数据。"
    },
    {
        "问题": "你觉得什么时候需要用到单例模式？",
        "答案": "单例模式用于确保一个类在整个应用程序中只有一个实例存在，并提供一个全局访问点。常见使用场景包括日志管理器、数据库连接池、配置管理器、线程池等需要共享资源或统一状态管理的场合。"
    },
    {
        "问题": "解释下线程安全和不安全。",
        "答案": "线程安全是指在多线程环境下，一个类、方法或变量能够在并发访问时表现出正确的行为。而线程不安全则意味着在并发访问下可能会出现数据不一致、竞态条件等问题。"
    },
    {
        "问题": "介绍下黑马点评，是直接拿到run了下吗，自己有没有创新？",
        "答案": "黑马点评是一个基于Java技术栈开发的仿美团外卖评论系统的实战项目，主要用于帮助初学者掌握SpringBoot、Redis、MySQL等后端开发技术。它不是一个简单的“拿来即跑”的项目，而是需要理解其业务逻辑和系统架构，并在此基础上进行个性化扩展与创新。"
    },
    {
        "问题": "你用MQ做什么，为什么选择RabbitMQ，其他的了解过吗？",
        "答案": "我使用消息队列（MQ）来实现系统之间的异步通信、流量削峰填谷、解耦合以及提升系统的可扩展性。选择RabbitMQ的原因包括：它支持多种消息协议（如AMQP）、有丰富的功能（延迟队列、死信队列等）、高可靠性、社区活跃，且易于集成到Spring Boot等主流框架中。其他常见的MQ包括Kafka、RocketMQ、ActiveMQ。Kafka适合大数据场景和日志收集；RocketMQ是阿里开源的，适合高并发场景；ActiveMQ较老，性能不如前几种。"
    },
    {
        "问题": "秒杀的业务流程是什么？",
        "答案": "秒杀业务流程通常包括：用户请求预处理、库存检查与扣减、订单生成、支付回调等步骤，整个过程需考虑并发控制、防止超卖、限流降级等问题。"
    },
    {
        "问题": "秒杀场景里哪里存着真正的库存量？库存扣减都是在哪里做的，Redis和底层DB？",
        "答案": "在秒杀系统中，真正的库存量通常存储在两个地方：底层数据库（如MySQL）和缓存中间件（如Redis）。其中，Redis用于高性能的实时库存读写操作，而底层数据库则作为持久化存储，保存最终一致性的库存数据。库存扣减主要是在Redis中完成，以应对高并发请求，随后异步或批量更新到底层数据库。"
    },
    {
        "问题": "Redis库存预减，那要是MySQL扣减失败怎么办，你怎么把库存还回去？",
        "答案": "当使用Redis进行库存预减，而后续MySQL扣减失败时，需要将Redis中的库存恢复。可以通过事务机制、消息队列补偿、或本地事务表等手段实现一致性。最常见的方式是引入最终一致性的补偿机制，比如通过消息队列异步回补库存。"
    },
    {
        "问题": "你异步生成订单，用户这么得到订单的ID，ID这么生成的？",
        "答案": "在异步生成订单的场景中，用户获取订单ID的方式通常是通过异步回调机制或轮询查询。订单ID的生成方式一般采用唯一性保障的算法，如UUID、Snowflake、时间戳+序列号等方式。"
    },
    {
        "问题": "要是这个key过期了呢？",
        "答案": "当一个设置了过期时间的 key 过期后，Redis 会根据配置的淘汰策略（eviction policy）来决定是否删除该 key。即使这个 key 是高频访问的，只要它设置了过期时间并且已经过期，Redis 就会在下一次访问时发现其已过期并进行删除操作。如果内存不足，则还会结合淘汰策略来决定是否主动删除某些 key。"
    },
    {
        "问题": "幂等性怎么保证的，重试的时间是怎么设计的，为什么这么设计？",
        "答案": "幂等性是指多次执行同一个操作与执行一次的效果相同。在分布式系统或网络请求中，保证幂等性通常通过唯一标识符（如 requestId）、数据库的唯一约束、状态机机制等方式实现。重试时间的设计一般采用指数退避（Exponential Backoff）策略，以减少对系统的冲击并提高成功率。"
    },
    {
        "问题": "数据一致性怎么保证，写频繁的情况下，MQ消息堆积这么办？",
        "答案": "在写频繁的情况下，保证数据一致性通常需要结合分布式事务、幂等性设计、补偿机制以及消息队列（MQ）的可靠性投递机制。对于MQ消息堆积问题，可以通过优化消费者处理能力、增加消费者实例、设置合理的重试策略和死信队列等方式缓解。"
    },
    {
        "问题": "Redis是集群吗，集群有主节点吗，主节点之间有什么联系吗？",
        "答案": "Redis 集群是一种分布式数据库架构，用于在多个节点上分片数据以实现高可用性和可扩展性。Redis 集群中没有传统意义上的“主节点”概念，而是使用去中心化的结构，但每个槽（slot）范围由一个主节点负责。集群中的节点分为“主节点（Master）”和“从节点（Slave）”，主节点之间通过 Gossip 协议进行通信，维护整个集群的状态一致性。"
    },
    {
        "问题": "Redis的线程模型，Redis的持久化操作，知道这么定位一个Key存在与否？",
        "答案": "Redis 使用单线程模型来处理客户端请求，但底层使用 I/O 多路复用技术（如 epoll、kqueue）实现高并发。Redis 的持久化机制主要包括 RDB 和 AOF 两种方式。判断一个 key 是否存在可以通过 EXISTS 命令来实现。"
    },
    {
        "问题": "大模型知道哪些，都拿来做什么，transform的内容可以聊聊吗？",
        "答案": "大模型是基于深度学习技术构建的具有大规模参数量的语言模型，它们能够理解、生成和推理自然语言。常见的大模型包括GPT系列、BERT、T5、LLaMA等。这些模型可以用于文本生成、机器翻译、问答系统、代码生成、摘要生成、对话系统等多个领域。"
    },
    {
        "问题": "谈谈你对AOP的理解？",
        "答案": "AOP是一种编程范式，旨在通过将横切关注点（如日志、事务管理、安全控制等）与核心业务逻辑分离，提高代码的模块化程度和可维护性。它通常在不修改原有业务代码的前提下，实现对功能的增强。"
    },
    {
        "问题": "hashmap的底层原理？",
        "答案": "HashMap 是基于哈希表实现的键值对存储结构，它通过哈希函数将键（Key）映射到数组中的某个位置，然后在该位置存储对应的值（Value）。当发生哈希冲突时（即不同的 Key 映射到同一个数组索引），HashMap 使用链表或红黑树来处理这些冲突。JDK 1.8 及以后版本中，当链表长度超过阈值（默认为8）时，链表会转换为红黑树以提高查找效率。"
    },
    {
        "问题": "hashmap是否线程安全？",
        "答案": "HashMap在Java中不是线程安全的。如果多个线程同时访问一个HashMap，并且至少有一个线程修改了结构（例如put或remove操作），那么必须通过外部同步来保证线程安全。"
    },
    {
        "问题": "concurrenthashmap的底层原理？为什么线程安全？",
        "答案": "ConcurrentHashMap 是 Java 中用于实现线程安全的哈希表结构的类，它在多线程环境下能够高效地支持并发读写操作。其底层原理主要依赖于分段锁（Segment）机制（在 Java 7 及以前）或 synchronized + CAS（在 Java 8 及以后），并通过 Node 链表或红黑树来存储键值对。"
    },
    {
        "问题": "sychronized的底层原理？",
        "答案": "synchronized 是 Java 中用于实现线程同步的关键字，其底层原理基于 JVM 的监视器（Monitor）机制，依赖于操作系统的互斥锁（Mutex Lock）来实现线程的同步与互斥。"
    },
    {
        "问题": "jdk动态代理的底层原理？",
        "答案": "JDK动态代理的底层原理是通过反射机制和字节码操作，在运行时动态生成一个实现指定接口的代理类，该代理类会将方法调用转发给一个InvocationHandler对象进行处理。"
    },
    {
        "问题": "反射可以用在哪里呢？",
        "答案": "反射（Reflection）是一种在运行时动态获取类信息、访问类属性和方法的机制。它广泛应用于框架设计、依赖注入、序列化与反序列化、插件系统、测试工具等领域。"
    },
    {
        "问题": "了解线程池吗，解释一下线程池？",
        "答案": "线程池是一种多线程处理形式，它维护多个线程并管理它们的生命周期和任务调度。线程池的核心目的是减少创建和销毁线程的开销，提高系统响应速度和资源利用率。通过复用已有的线程来执行多个任务，避免了频繁地创建和销毁线程带来的性能损耗。"
    },
    {
        "问题": "线程池的核心参数有哪些？",
        "答案": "线程池的核心参数主要包括以下几个： corePoolSize：核心线程数 maximumPoolSize：最大线程数 keepAliveTime：空闲线程存活时间 unit：存活时间的单位 workQueue：任务队列 threadFactory：线程工厂 handler：拒绝策略"
    },
    {
        "问题": "拒绝策略有哪些？",
        "答案": "拒绝策略是线程池在任务队列已满且无法继续接收新任务时所采取的处理方式。常见的拒绝策略包括以下四种： AbortPolicy（中止策略）：默认策略，抛出 RejectedExecutionException 异常。 CallerRunsPolicy（调用者运行策略）：由提交任务的线程自己执行该任务。 DiscardOldestPolicy（丢弃最旧任务策略）：丢弃队列中最老的任务，然后尝试重新提交当前任务。 DiscardPolicy（丢弃任务策略）：静默地丢弃任务，不抛出异常也不执行。"
    },
    {
        "问题": "如果核心线程数为0，那任务传过来线程池的核心线程数会怎么变化？",
        "答案": "如果线程池的核心线程数设置为0，在默认行为下，线程池不会创建任何核心线程来处理任务。所有任务将由非核心线程（maximumPoolSize）处理，并且这些线程在空闲超时后会被回收。也就是说，线程池的行为将完全依赖于 maximumPoolSize 和 keepAliveTime 的配置。"
    },
    {
        "问题": "bean的生命周期？",
        "答案": "在Spring框架中，Bean的生命周期是指从Bean的创建、初始化、使用到销毁的整个过程。这个过程由Spring容器管理，开发者可以通过配置或实现特定接口来干预Bean的初始化和销毁行为。"
    },
    {
        "问题": "循环依赖了解吗？",
        "答案": "循环依赖是指两个或多个对象之间相互持有对方的引用，导致它们在初始化或销毁时无法正常完成生命周期管理。在Spring等依赖注入框架中，循环依赖是一个常见的问题，尤其是在单例Bean之间。"
    },
    {
        "问题": "spring是怎么解决循环依赖的？",
        "答案": "Spring 通过三级缓存机制解决单例 Bean 的循环依赖问题。具体来说，Spring 容器使用三个 Map 缓存来管理正在创建的 Bean 实例和工厂对象，分别是： singletonObjects：一级缓存，存放完全初始化好的 Bean。 earlySingletonObjects：二级缓存，存放提前暴露的“早期 Bean”（未完全初始化）。 singletonFactories：三级缓存，存放 Bean 工厂对象（ObjectFactory），用于生成早期 Bean。"
    },
    {
        "问题": "操作系统进程和线程的区别？",
        "答案": "进程是操作系统资源分配的基本单位，而线程是CPU调度和执行的基本单位。一个进程可以包含多个线程，这些线程共享该进程的地址空间和资源。"
    },
    {
        "问题": "说一下虚拟内存，为什么需要虚拟内存？",
        "答案": "虚拟内存是一种由操作系统提供的内存管理技术，它允许程序使用比实际物理内存更大的地址空间。每个进程都拥有独立的虚拟地址空间，而操作系统负责将虚拟地址映射到物理地址。"
    },
    {
        "问题": "dlopen如何加载动态链接库？",
        "答案": "dlopen 是 Linux 系统中用于动态加载共享库（即 .so 文件）的函数，属于 dlfcn.h 头文件提供的 API。它允许程序在运行时按需加载并使用共享库中的符号（如函数和全局变量）。"
    },
    {
        "问题": "指针和引用的区别？",
        "答案": "指针和引用在C++中都可以用于间接访问变量，但它们有本质的区别。指针是一个变量，存储的是另一个变量的内存地址；而引用是某个已存在变量的别名，对引用的操作等价于对原变量的操作。"
    },
    {
        "问题": "如何用cmake生成静态链接库 动态链接库？",
        "答案": "使用 CMake 可以很方便地生成静态链接库（.a 或 .lib）和动态链接库（.so 或 .dll），只需要在 CMakeLists.txt 中分别使用 add_library 命令并指定 STATIC 或 SHARED 参数即可。"
    },
    {
        "问题": "Cmake中 private、 public、interface区别？",
        "答案": "在 CMake 中，PRIVATE、PUBLIC 和 INTERFACE 是用于控制目标（target）之间依赖关系和属性传递的关键字。它们决定了依赖项的可见性和传播方式。 PRIVATE 表示该依赖仅对当前目标内部有效，不会传递给链接当前目标的其他目标。 PUBLIC 表示该依赖不仅对当前目标有效，还会传递给所有链接当前目标的目标。 INTERFACE 表示该依赖不作用于当前目标本身，只传递给使用当前目标的目标。"
    },
    {
        "问题": "动态链接库对比静态链接库有哪些好处？",
        "答案": "动态链接库（DLL）相比静态链接库（Static Library）主要有以下好处：节省内存和磁盘空间、便于更新维护、支持运行时加载和卸载、提高代码复用性。"
    },
    {
        "问题": "谈谈C17的新特性。",
        "答案": "：C17（也称为C17或C1X）是ISO C语言标准的最新版本，于2018年正式发布。它主要是一次小幅度的更新，修复了C11中的一些缺陷，并引入了一些新特性以增强语言的安全性、可移植性和易用性。主要的新特性包括：_Alignas 和 _Alignof 的改进、__STDC_ALLOC_LIB__ 宏、__STDC_NO_ATOMICS__ 等原子操作相关宏、删除 gets() 函数、新增 <stdckdint.h> 头文件、允许在 _Generic 关键字中使用类型默认分支等。"
    },
    {
        "问题": "使用过多线程编程吗，说下大体方式。",
        "答案": "多线程编程是一种并发编程技术，它允许一个程序同时执行多个任务（线程）。在Java中可以通过继承Thread类或实现Runnable接口来创建线程；在C++中可以使用std::thread；在Python中可以使用threading模块。核心思想是将任务分解为多个可并行执行的线程。"
    },
    {
        "问题": "死锁如何产生的，如何避免死锁？",
        "答案": "死锁是指多个进程或线程在执行过程中，因争夺资源而造成的一种相互等待的状态。每个进程/线程都持有部分资源，并等待其他进程/线程释放它所需要的资源，导致所有相关进程/线程都无法继续执行。"
    },
    {
        "问题": "什么是内存泄漏，怎么避免，发生了如何排除？",
        "答案": "内存泄漏是指程序在运行过程中动态分配了内存，但在使用完成后没有及时释放，导致这部分内存无法被再次使用，造成资源浪费。长期运行可能导致程序或系统崩溃。避免内存泄漏的方法包括良好的编程习惯、使用智能指针（C++）、垃圾回收机制（Java等语言）以及工具检测。排查内存泄漏可以使用Valgrind、VisualVM、MAT等工具。"
    },
    {
        "问题": "什么是gui线程？",
        "答案": "GUI线程是指负责处理图形用户界面（Graphical User Interface）相关操作的线程。它负责响应用户的输入（如点击、拖动等）、更新界面元素以及绘制窗口内容。在大多数GUI框架中，所有与界面交互的操作都必须在GUI线程中执行，以避免并发访问导致的状态不一致问题。"
    },
    {
        "问题": "了解ffmpeg吗？",
        "答案": "FFmpeg 是一个强大的开源多媒体框架，能够处理音视频的编码、解码、转码、封装、解封装、流媒体传输等多种任务。它支持多种音视频格式和编解码器，并提供了命令行工具 ffmpeg 以及一系列开发库供开发者使用。"
    },
    {
        "问题": "什么情况下会用std::optional？",
        "答案": "std::optional 是 C++17 引入的一个模板类，用于表示一个值可能存在也可能不存在的情况。它常用于函数返回值、结构体字段等需要表达“可选值”的场景。"
    },
    {
        "问题": "网络TIME_WAIT的状态意义？",
        "答案": "TIME_WAIT状态是TCP协议中的一种连接终止状态，表示主动关闭连接的一方在完成四次挥手后进入等待状态，持续时间为2MSL（Maximum Segment Lifetime），目的是确保网络中残留的报文段失效，防止旧连接的报文干扰新连接。"
    },
    {
        "问题": "谈谈HTTPS握手过程？",
        "答案": "HTTPS握手过程是客户端和服务器在建立安全通信之前进行的一系列协商，目的是通过TLS/SSL协议交换加密密钥并验证身份。主要步骤包括：TCP三次握手、客户端发送ClientHello、服务器响应ServerHello、证书交换、密钥交换、完成握手。"
    },
    {
        "问题": "谈谈你在使用线程池遇到的问题。",
        "答案": "使用线程池时常见的问题包括线程饥饿、死锁、资源竞争、任务堆积、线程泄漏、配置不当等。这些问题可能导致系统性能下降，甚至崩溃。"
    },
    {
        "问题": "Redis的Zset的底层结构？",
        "答案": "Redis中的ZSET（有序集合）底层使用了两种数据结构进行实现：跳跃表（SkipList）和哈希表（Hash Table）。跳跃表用于维护元素的排序，而哈希表用于实现O(1)时间复杂度的元素查找。"
    },
    {
        "问题": "volatile的作用？",
        "答案": "volatile 是 C/C++ 中的一个类型限定符，用于告诉编译器该变量的值可能会在程序不知情的情况下被改变（例如由硬件寄存器、中断服务程序或多线程环境），因此每次访问该变量时都必须从内存中读取，而不是使用寄存器中的缓存值。"
    },
    {
        "问题": "你一般引入redis做什么？",
        "答案": "Redis 通常被引入用于缓存、提高系统性能、减轻数据库压力、实现分布式锁、消息队列等功能。它是一个高性能的键值存储系统，支持多种数据结构如字符串、哈希、列表、集合等。"
    },
    {
        "问题": "二叉树最近公共祖先?",
        "答案": "二叉树中两个节点的最近公共祖先（Lowest Common Ancestor, LCA）是指在二叉树中同时是这两个节点祖先，并且距离这两个节点最近的那个节点。LCA 可以通过递归的方式从根节点开始查找。"
    },
    {
        "问题": "联合索引的范围查询是否可以用到索引，x1x2x3上使用x1x3能走索引吗?",
        "答案": "在联合索引（x1, x2, x3）上，如果查询条件使用的是 x1 和 x3 而跳过了中间的 x2，则通常无法有效利用该联合索引进行范围查询。但如果是等值查询（例如 WHERE x1 = a AND x3 = c），则可能部分使用到索引。"
    },
    {
        "问题": "组合索引的update在多种情况下的间隙锁的范围?",
        "答案": "在使用组合索引（复合索引）进行 UPDATE 操作时，InnoDB 存储引擎会根据 WHERE 条件和索引的结构来加锁，其中间隙锁（Gap Lock）用于防止其他事务插入数据到当前事务正在操作的索引范围中。间隙锁的具体范围取决于查询条件是否精确匹配、是否有范围扫描以及是否存在唯一索引等。"
    },
    {
        "问题": "使用函数能走索引吗?",
        "答案": "在大多数编程语言中，函数本身不能直接作为索引使用。索引通常用于访问数组、列表、字符串等数据结构中的元素，而函数是可调用的代码块或对象。然而，在某些上下文中，函数可以返回一个可用于索引的值（如整数），从而实现间接的“函数走索引”。"
    },
    {
        "问题": "字段没有索引，通过where x = 3 for update是使用什么级别的锁?",
        "答案": "在没有索引的情况下，执行 WHERE x = 3 FOR UPDATE 语句会对整张表进行扫描，并对所有扫描到的记录加上行级锁（Row-Level Lock），但因为没有索引，InnoDB 存储引擎可能会升级为间隙锁（Gap Lock）或临键锁（Next-Key Lock），从而锁定范围，甚至可能造成全表锁定的现象。"
    },
    {
        "问题": "arraylist和linkedlist的区别?",
        "答案": "ArrayList 和 LinkedList 是 Java 中常用的两种线性数据结构实现类，它们都实现了 List 接口。主要区别体现在底层数据结构、访问效率、插入和删除效率等方面。"
    },
    {
        "问题": "说说对数据库中索引的理解。",
        "答案": "索引是数据库中用于加速数据检索的一种数据结构。它类似于书籍的目录，可以显著加快对表中数据的查询速度，但会占用额外存储空间并可能降低写操作（如插入、更新、删除）的速度。"
    },
    {
        "问题": "工厂模式和策略模式？",
        "答案": "工厂模式和策略模式是两种常见的设计模式，分别属于创建型模式和行为型模式。 工厂模式用于封装对象的创建过程，将对象的使用与创建解耦；策略模式用于定义一系列算法，使它们可以互相替换，使得算法的变化独立于使用它的客户端。"
    },
    {
        "问题": "hashmap的put过程？",
        "答案": "HashMap 的 put 过程是将键值对插入到哈希表中。其基本流程是：计算 key 的哈希值，定位到数组的索引位置，如果发生哈希冲突则使用链表或红黑树处理冲突，最终将键值对插入合适的位置。"
    },
    {
        "问题": "面向对象三大特征？",
        "答案": "面向对象编程（OOP）的三大特征是封装（Encapsulation）、继承（Inheritance）和多态（Polymorphism）。这三者构成了面向对象编程的核心理念，帮助开发者实现模块化、可扩展和可维护的代码结构。"
    },
    {
        "问题": "jvm内存区域？",
        "答案": "JVM（Java Virtual Machine）内存区域主要包括方法区、堆、虚拟机栈、本地方法栈和程序计数器。这些区域在JVM启动时创建，用于存储运行时数据结构和对象实例等信息。"
    },
    {
        "问题": "jvm有什么组成？",
        "答案": "JVM（Java Virtual Machine）是Java运行的核心，主要由类加载器子系统、运行时数据区（内存模型）、执行引擎、本地方法接口和垃圾回收器等组成。每个组件协同工作，实现Java程序的编译、加载、执行与内存管理。"
    },
    {
        "问题": "谈谈jvm垃圾回收算法。",
        "答案": "JVM中的垃圾回收算法主要包括标记-清除（Mark-Sweep）、复制（Copying）、标记-整理（Mark-Compact）和分代收集（Generational Collection）等。这些算法用于自动管理内存，识别并回收不再使用的对象以释放内存空间。"
    },
    {
        "问题": "事务隔离级别是什么？",
        "答案": "事务隔离级别是数据库管理系统中用于控制事务并发执行时数据可见性和一致性的机制。SQL标准定义了四种隔离级别：读未提交（Read Uncommitted）、读已提交（Read Committed）、可重复读（Repeatable Read）和串行化（Serializable）。此外，还有一种中间级别称为“读已提交快照（Read Committed Snapshot）”，以及“可重复读快照（Repeatable Read Snapshot）”等实现变种。"
    },
    {
        "问题": "SpringCloud核心组件的原理？",
        "答案": "Spring Cloud 是一套用于构建分布式系统的微服务架构解决方案，其核心组件包括：Eureka（服务注册与发现）、Ribbon（客户端负载均衡）、Feign（声明式服务调用）、Hystrix（服务熔断降级）、Zuul（API网关）、Config（配置中心）、Gateway（新一代网关）、Sleuth/Zipkin（分布式链路追踪）等。每个组件都有其特定的职责和实现原理。"
    },
    {
        "问题": "如何进行sql调优？",
        "答案": "SQL调优是指通过分析和优化数据库查询语句，提升其执行效率、减少资源消耗的过程。常见的优化手段包括：合理使用索引、避免全表扫描、优化查询结构、减少不必要的数据处理、调整数据库配置等。"
    },
    {
        "问题": "如何优化limit 分页？",
        "答案": "优化 LIMIT 分页的核心方法包括避免深度分页、使用索引扫描、使用游标分页（Cursor-based Pagination）或结合排序字段与索引进行高效查询。"
    },
    {
        "问题": "在2核8G内存的主机中，如何使用java多线程来下载10g文件？",
        "答案": "在2核8G内存的主机中，使用Java多线程下载10G文件的核心思路是将文件分块（Range Download），每个线程负责下载一个部分，最后合并这些部分。通过HTTP协议的 Range 请求头实现分段下载。"
    },
    {
        "问题": "对象从新生代到老年代的过程？",
        "答案": "在Java虚拟机（JVM）的垃圾回收机制中，对象通常首先分配在新生代（Young Generation），经过多次Minor GC后仍然存活的对象会被晋升（Tenuring）到老年代（Old Generation）。这个过程主要依赖于对象的年龄阈值和GC策略。"
    },
    {
        "问题": "行级锁表级锁的区别？",
        "答案": "行级锁和表级锁是数据库中用于控制并发访问的两种不同粒度的锁机制。行级锁只锁定特定的行，允许多个事务同时访问表中的不同行，从而提高了并发性；而表级锁则锁定整个表，在锁释放之前其他事务不能访问该表的任何数据，适用于读多写少的场景。"
    },
    {
        "问题": "什么是垃圾回收算法？",
        "答案": "垃圾回收（Garbage Collection, GC）是自动内存管理机制，用于识别并释放不再被程序使用的对象所占用的内存空间。常见的垃圾回收算法包括标记-清除、复制、标记-整理和分代收集等。"
    },
    {
        "问题": "为什么采用redis分布式锁，而不使用java本来的锁？",
        "答案": "在分布式系统中，Java本地锁（如synchronized、ReentrantLock）无法跨JVM或跨节点生效，而Redis分布式锁可以协调多个服务实例对共享资源的访问，保证在分布式环境下数据的一致性和互斥性。"
    },
    {
        "问题": "可不可以使用数据库的锁来完成锁的实现？",
        "答案": "可以使用数据库的锁来实现锁机制，但需要根据具体业务场景选择合适的锁类型（如行级锁、表级锁）和隔离级别。数据库锁通常用于保证事务的原子性和一致性，在分布式系统中也可以作为协调多个进程或线程访问共享资源的一种方式。"
    },
    {
        "问题": "ES的原理？",
        "答案": "Elasticsearch（简称ES）是一个基于Lucene的分布式搜索引擎，支持全文搜索、结构化搜索、分析等功能。其核心原理包括倒排索引、分片机制、分布式架构与查询执行流程。"
    },
    {
        "问题": "分布式锁、redisson的实现？",
        "答案": "分布式锁是一种在分布式系统中用于协调多个节点对共享资源访问的机制。Redisson 是一个基于 Redis 的 Java 客户端，它提供了多种分布式锁实现，如 RLock 接口下的 RedissonLock，其底层使用 Redis 的 Lua 脚本和过期时间机制来保证锁的安全性和可靠性。"
    },
    {
        "问题": "Redis数据结构？",
        "答案": "Redis 是一个开源的内存数据库，支持多种数据结构。其核心数据结构包括字符串（String）、哈希（Hash）、列表（List）、集合（Set）和有序集合（Sorted Set）。这些数据结构在底层由不同的编码方式实现，例如 SDS（简单动态字符串）、字典、双端链表、跳跃表等。"
    },
    {
        "问题": "聚集索引和非聚集索引是什么？",
        "答案": "聚集索引（Clustered Index）决定了表中数据的物理存储顺序，一个表只能有一个聚集索引。非聚集索引（Non-clustered Index）是独立于数据行存储的结构，它包含索引键值和指向实际数据行的指针（或聚集索引键）。一个表可以有多个非聚集索引。"
    },
    {
        "问题": "什么是B+树？",
        "答案": "B+树是一种自平衡的树数据结构，广泛用于数据库和文件系统中进行高效的数据存储与检索。它与B树类似，但所有数据都存储在叶子节点中，并且叶子节点之间通过指针连接形成链表结构，便于范围查询。"
    },
    {
        "问题": "解释一下事务ACID和隔离级别。",
        "答案": "事务的ACID特性是指原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。这四个特性保证了数据库事务在并发操作和系统故障情况下依然能保持数据的完整性和一致性。事务的隔离级别定义了事务之间可见性的程度，常见的有读未提交（Read Uncommitted）、读已提交（Read Committed）、可重复读（Repeatable Read）和串行化（Serializable），不同隔离级别可以防止不同的并发问题，如脏读、不可重复读、幻读等。"
    },
    {
        "问题": "数据量大时该如何怎么优化呢？需要避免OOM，如果导出时间过长该如何解决？",
        "答案": "当数据量大时，优化的核心在于减少内存占用和提升处理效率。为了避免OOM（Out of Memory），需要采用分页查询、流式处理、批量操作等方式；若导出时间过长，则应考虑异步处理、多线程/协程、压缩传输、索引优化等手段。"
    },
    {
        "问题": "存储底层数据结构是什么？",
        "答案": "存储底层数据结构通常指的是操作系统中用于管理磁盘或内存存储的数据结构。常见的包括文件系统的索引节点（inode）、位图（bitmap）用于空闲空间管理、B树/B+树用于数据库和文件系统的高效检索，以及哈希表用于快速查找等。"
    },
    {
        "问题": "为什么选择跳表？",
        "答案": "跳表（Skip List）是一种基于链表结构的高效数据结构，支持快速的插入、删除和查找操作。选择跳表的原因主要包括其良好的平均时间复杂度（O(log n)）、实现相对简单、支持并发访问以及动态适应性强等优点。"
    },
    {
        "问题": "跳表是如何插入的，是否有顺序，key用什么？",
        "答案": "跳表（Skip List）是一种基于链表结构的高效查找数据结构，支持插入、删除和查找操作，平均时间复杂度为 O(log n)。插入跳表时需要按照 key 的顺序进行排序，key 通常使用可比较的数据类型（如整数、字符串等），以便维持跳表中节点的有序性。"
    },
    {
        "问题": "什么是持久化写入时机？",
        "答案": "持久化写入时机指的是将数据从内存写入磁盘的策略，常见于数据库、日志系统、缓存系统等场景。常见的持久化方式包括同步写入（sync）和异步写入（async），它们决定了数据在何时被真正落盘以确保可靠性。"
    },
    {
        "问题": "leader复活后会发生什么？",
        "答案": "在分布式系统中，leader复活通常指的是在一个已经选出新的leader的集群中，原来的leader重新加入的情况。这种情况下可能会出现“脑裂”（split brain）问题，即两个节点都认为自己是leader，从而导致数据不一致或服务不可用。因此，分布式系统必须设计机制来处理leader复活的问题。"
    },
    {
        "问题": "各个节点是否会保存其他节点的数据，保存哪些数据？",
        "答案": "在分布式系统和网络结构中，不同节点是否保存其他节点的数据取决于具体的系统设计和数据管理策略。常见的做法包括：不保存（如纯转发节点）、部分保存（如缓存、副本机制）、完整保存（如主从架构中的主节点）。具体保存的内容可以是元数据（如节点ID、IP地址、状态）、数据副本、路由表、心跳信息等。"
    },
    {
        "问题": "重复写入一个key的value如何处理？",
        "答案": "当重复写入一个key的value时，通常的做法是使用最后一次写入的value覆盖之前的value。这是大多数键值存储系统（如哈希表、字典）的标准行为。"
    },
    {
        "问题": "说一下智能指针。",
        "答案": "智能指针是C++中用于管理动态内存的类模板，它通过对象来封装原始指针，自动在合适的时候释放内存，从而避免内存泄漏。常见的智能指针包括std::unique_ptr、std::shared_ptr和std::weak_ptr。"
    },
    {
        "问题": "为什么要weak指针？",
        "答案": "weak指针用于解决循环引用问题，它不会增加所指向对象的引用计数。在C++中，特别是在使用shared_ptr时，weak_ptr可以安全地观察或访问一个对象，而不会影响该对象的生命周期。"
    },
    {
        "问题": "unique指针如何转移资源？",
        "答案": "在C++中，std::unique_ptr 是一种独占式智能指针，表示对资源的唯一所有权。由于其不可复制（copy）特性，资源不能通过拷贝构造或拷贝赋值来转移，但可以通过移动语义（move semantics）将资源从一个 unique_ptr 转移给另一个。"
    },
    {
        "问题": "右值引用有了解吗？",
        "答案": "右值引用是C++11引入的一个新特性，用于支持移动语义和完美转发。它通过两个&符号（&&）定义，能够绑定到临时对象（即右值），从而避免不必要的拷贝操作，提高性能。"
    },
    {
        "问题": "移动构造如何实现的？",
        "答案": "移动构造是C++11引入的一种构造方式，用于在对象之间转移资源（如堆内存、文件句柄等）而不是复制。它通过右值引用（T&&）实现，避免了不必要的深拷贝，提高了性能。移动构造函数的典型形式为：ClassName(ClassName&& other)。"
    },
    {
        "问题": "多态是如何实现的？",
        "答案": "多态是面向对象编程中的一种特性，允许不同类的对象对同一消息作出不同的响应。在C++和Java等语言中，多态主要通过继承和虚函数（或接口实现）来实现。运行时多态的实现依赖于虚函数表（vtable）和虚指针（vptr）机制。"
    },
    {
        "问题": "多个子类的对象，有几张虚函数表？",
        "答案": "每个具有虚函数的类（包括子类）在C++中都会有一个对应的虚函数表（vtable）。如果有多个子类的对象，每个对象所属的类都有自己的虚函数表。因此，如果存在多个不同的子类，并且它们各自重写了虚函数或定义了新的虚函数，则每个子类将拥有一张独立的虚函数表。"
    },
    {
        "问题": "多继承的子类有几张虚函数表？",
        "答案": "在C++中，如果一个子类继承了多个父类，并且这些父类中包含虚函数，则该子类会拥有与父类数量相等的虚函数表（vtable）。每个虚函数表对应一个基类的虚函数集合。"
    },
    {
        "问题": "stl有了解吗？",
        "答案": "STL是C++标准库的一部分，提供了一组通用的模板类和函数，用于实现常用的数据结构与算法。STL主要包括容器（Containers）、迭代器（Iterators）、算法（Algorithms）和函数对象（Functors）四大组件。"
    },
    {
        "问题": "map和unorder_map的区别？",
        "答案": "map 和 unordered_map 是 C++ STL 中的两种关联容器，用于存储键值对。它们的主要区别在于底层实现、有序性、查找效率和内存使用等方面。"
    },
    {
        "问题": "Linux通讯命令，通讯原理是什么？",
        "答案": "Linux中常见的通讯命令包括 ping、telnet、nc（Netcat）、ssh、curl 等，它们的底层通讯原理基于TCP/IP协议栈，涉及网络层、传输层和应用层。这些命令通过系统调用如 socket()、connect()、send() 和 recv() 实现进程间或主机间的通信。"
    },
    {
        "问题": "tcp三次握手，为什么必须要三次？",
        "答案": "TCP三次握手的目的是为了确保通信双方都能确认对方的发送和接收能力是正常的，并且建立一个可靠的连接。之所以必须进行三次握手，是为了防止已经失效的连接请求突然传到服务器，造成资源浪费或错误连接。"
    },
    {
        "问题": "hashmap底层原理，有哪些线程安全的map？",
        "答案": "HashMap 是 Java 中基于哈希表实现的 Map 接口，其底层通过数组 + 链表（或红黑树）结构来存储键值对。当发生哈希冲突时，使用链地址法处理，JDK 8 后引入了红黑树优化长链表查询效率。线程安全的 Map 实现包括 Hashtable、Collections.synchronizedMap() 包装的 Map，以及并发性能更好的 ConcurrentHashMap。"
    },
    {
        "问题": "concurrenthashmap，问底层原理，怎么加锁的？",
        "答案": "ConcurrentHashMap 是 Java 中用于高并发场景下的线程安全哈希表实现。其底层原理是通过分段锁（Segment）机制（JDK 1.7）或 synchronized + CAS（JDK 1.8）来实现高效的并发访问。加锁粒度更细，提高了并发性能。"
    },
    {
        "问题": "pringboot启动注解是什么，内部的四个实际注解讲一下。",
        "答案": "Spring Boot 启动类中常用的注解是 @SpringBootApplication，它是一个组合注解，内部包含了四个核心注解：@SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan 和 @AliasFor（虽然 @AliasFor 是元注解，但它是支撑其他注解功能的基础）。"
    },
    {
        "问题": "深挖索引，联合索引，ABC BC AC 怎么走索引，索引下推是什么，索引优化查询命令各个字段讲一下。",
        "答案": "在数据库中，索引是用于加速查询的重要机制。对于联合索引（也称复合索引），如 (A, B, C)，其存储结构是按照字段顺序构建的B+树索引。当查询条件涉及多个字段时，是否能使用该索引取决于查询条件是否满足最左前缀原则。 查询 WHERE A = ? AND B = ? AND C = ?：可以命中索引 (A, B, C)。 查询 WHERE B = ? AND C = ?：无法命中索引 (A, B, C)，因为缺少最左列 A。 查询 WHERE A = ? AND C = ?：只能用到索引中的 A 字段，C 不会参与索引查找，因为中间跳过了 B。 查询 WHERE A = ? AND B > ?：可以使用索引直到 B 的范围扫描，C 不再参与。 索引下推（Index Condition Pushdown，ICP）是一种优化技术，允许将部分 WHERE 条件的判断下推到存储引擎层，在访问数据页之前就过滤掉不符合条件的数据，从而减少 I/O 操作。"
    }
]